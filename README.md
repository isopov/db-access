# Пример работы с базами данных из java-приложения на spring-boot

## Создание базы данных по схеме

В этом примере используется база H2 (а не Mysql или Postgresql) - она создаётся автоматически из src/main/resources/schema.sql при старте приложения и живёт внутри jvm до остановки приложения.

В файле schema.sql вся наша схема пока записана в одну строчку - к сожалению это ограничение такого способа создания схемы - каждое выражение (отдельный create, alter, etc.) должно быть в одну строчку. В реальных проектах такой упрощенный способ не используется, а либо схема управляется отдельно от приложения, либо специальными библиотеками для проведения инициализации и миграций схемы базы данных (Flyway, liquibase, etc.), которые выходят за рамки данного примера.

Доступ к настроящей базе мы бы прописали в src/main/resources/application.properties например такими строками:
```
spring.datasource.url=jdbc:mysql://localhost/foobar
spring.datasource.username=foobar
spring.datasource.password=foobar
```
Но так как база у нас существует только в памяти jvm, нам это не нужно.

Но при этом в src/main/resources/application.properties мы записали строчку `spring.jpa.generate-ddl=false` - она переопределяет дефолтное поведение Hibernate (для spring-boot дефолтное, не факт, что для другого способа конфигурирования это тоже дефолт), который без неё попытался бы сам создать нужную схему БД.

## Функционал

Вся web-логика находится в классе AbstractController - у него есть несколько наследников, которые по-разному обращаются к базе данных, но все делают это через сервис, который представлен в базовом контроллере интерфейсом IService. Такое наследование сделано для демонстрации разных способов сделан одинаковый функционал - в реальных проектах, как правило, выбирается что-то одно и пользователей создают либо через jdbc, либо через template, либо через jpa. 

Все сервисы работают с базой через транзакции (все они отмечены аннотацией @Transactional) - при этом при нормальной работе приложения транзакция стартует в момент входа в метод сервиса, и завершается коммитом (если не произошло ошибки) в момент выхода из метода сервиса. В тестах же транзакция стартует вместе с тестом, эта же транзакция используется в сервисе, и после завершения теста транзакция откатывается - это позволяет нам писать в базу в тесте и проверять успешность записи, но оставить базу нетронутой после завершения теста.


## Способы работы с БД

Рассмотрим разные способы работы с базой:
### jdbc-datasource
В пакете jdbc находятся два класса (класс JdbcController только привязывает все методы доступные через web к префиксу jdbc и указывает, какую именно реализацию Service - JdbcService нужно использовать.

Логика работы с базой в JdbcService. Spring в этом классе почти не используется - мы только получаем стандартный DataSource из контекста и работаем полностью с ним.


### JdbcTemplate
В пакете template мы работаем с базой через спринговую обертку над DataSource. Кода уже существенно меньше и он проще. Нет обработки исключений (её фактически и не было, но код для работы с ними нам всё равно писать приходилось). Практически всё мы можем сделать одной строчкой.

### JPA
В пакете jpa мы работаем с той же базой (и теми же таблицами) через JPA. Логика привязки объекта к реляции (таблице) находится в аннотациях этого объекта - FoobarEntity.

## Что можно попробовать:

1. Обратиться из любого rest-клиента (можно из браузера - все методы контроллеров привязаны одновременно и к GET, и к POST методам) к разным методам разных контроллеров - так как база одна и та же, то объекты созданные из одного контроллера видны в других контроллерах.
2. Запустите тесты - зависят ли они друг от друга, и если да, то каким образом?
