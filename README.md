## Пример работы с базами данных из java-приложения на spring-boot

В этом примере используется база H2 (а не Mysql или Postgresql) - она создаётся автоматически из src/main/resources/schema.sql при старте приложения и живёт внутри jvm до остановки приложения.

Вся web-логика находится в классе AbstractController - у него есть несколько наследников, которые по-разному обращаются к базе данных, но все делают это через сервис, который представлен в базовом контроллере интерфейсом IService. 

Все сервисы работают с базой через транзакции (все они отмечены аннотацией @Transactional) - при этом при нормальной работе приложения транзакция стартует в момент входа в метод сервиса, и завершается коммитом (если не произошло ошибки) в момент выхода из метода сервиса. В тестах же транзакция стартует вместе с тестом, эта же транзакция используется в сервисе, и после завершения теста транзакция откатывается - это позволяет нам писать в базу в тесте и проверять успешность записи, но оставить базу нетронутой после завершения теста.

Рассмотрим разные способы работы с базой:

### jdbc-datasource
В пакете jdbc находятся два класса (класс JdbcController только привязывает все методы доступные через web к префиксу jdbc и указывает, какую именно реализацию Service - JdbcService нужно использовать.

Логика работы с базой в JdbcService. Spring в этом классе почти не используется - мы только получаем стандартный DataSource из контекста и работаем полностью с ним.


### JdbcTemplate
В пакете template мы работаем с базой через спринговую обертку над DataSource. Кода уже существенно меньше и он проще. Нет обработки исключений (её фактически и не было, но код для работы с ними нам всё равно писать приходилось). Практически всё мы можем сделать одной строчкой.

### JPA
В пакете jpa мы работаем с той же базой (и теми же таблицами) через JPA. Логика привязки объекта к реляции (таблице) находится в аннотациях этого объекта - FoobarEntity.

### Что можно попробовать:

1. Обратиться из любого rest-клиента (можно из браузера - все методы контроллеров привязаны одновременно и к GET, и к POST методам) к разным методам разных контроллеров - так как база одна и та же, то объекты созданные из одного контроллера видны в других контроллерах.
